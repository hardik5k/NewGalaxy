<html>
    <body onload="canvas.setup()">
        <canvas id="canvasArea"
        style="position: absolute; left: 0; top: 0; z-index: 0; width:100%;height:100%"></canvas>
        <script src="./canvas.js"></script>
    </body>
</html>

<script>
    // Global Variables
    var sunR;
    var shape;
    var circle_orbit_radius;
    var circle_orbit_x;
    var circle_orbit_y;
    var ellipse_major;
    var ellipse_minor;
    var square_left_x;
    var square_up_y;
    var square_side;
    var square_defence_speed;
    var triangle_top_x;
    var triangle_top_y;
    var triangle_halfside;
    var triangle_height;
    var triangle_speed;
    var t_y;
    var defence_x;
    var defence_y;
    var defence_theta;
    var Te1, Te2, Te3, Te4;



    function setup()
    {
        sunR = 17;
        circle_orbit_radius = 400;
        circle_orbit_x = canvas.width/2;
        circle_orbit_y = canvas.height/2;
        ellipse_major = 370;
        ellipse_minor = 270;
        square_side = 350;
        square_left_x = (canvas.width - square_side)/2;
        square_up_y = (canvas.height - square_side)/2;
        square_defence_speed = 5;
        t_y = 200;
        triangle_top_x = canvas.width/2;
        triangle_top_y = (canvas.height - t_y)/2;
        triangle_halfside = 100;
        triangle_height = Math.sqrt(3) * triangle_halfside;
        triangle_speed = 3;
        // circle initial
        //defence_x = canvas.width/2 + circle_orbit_radius;
        //defence_y = canvas.height/2;
        // square initial
        // defence_x = square_left_x;
        // defence_y = square_up_y;
        // triangle initial
        defence_x = triangle_top_x;
        defence_y = triangle_top_y;
        defence_theta = 60;
        Te1 = 0;
        Te2 = 0;
        Te3 = 0;
        Te4 = 0;
    }


    var COrbit = function(radius, color = "#5a5a5a")
    {
        r = radius;

        canvas.setDrawMode("stroke");
        canvas.setColor(color);
        canvas.drawCircle(circle_orbit_x, circle_orbit_y, radius);
        return r;
    }
    var EOrbit = function(major, minor)
    {
        a = major;
        b = minor;

        canvas.setDrawMode("stroke");
        canvas.setColor("#5a5a5a");
        canvas.drawEllipse(canvas.width/2, canvas.height/2, a,b,0,0,360);
        return [a,b];
    }
    var ROrbit = function(side)
    {
        a = side;

        canvas.setDrawMode("stroke");
        canvas.setColor("#5a5a5a");
        canvas.drawRectangle(square_left_x,square_up_y,side,side);
        return a;
    }
    var TOrbit = function(y,a)
    {
        canvas.setDrawMode("stroke");
        canvas.setColor("#5a5a5a");
        canvas.drawTriangle(triangle_top_x,triangle_top_y,a);

    }

    var Defence = function()
    {
        canvas.drawCircle(defence_x, defence_y, 20);
    }

    function move(key)
    {
      if(key.code == "ArrowUp")
      {
        defence_theta += 1;
        defence_x = canvas.width/2 + circle_orbit_radius * Math.cos(defence_theta * (Math.PI / 180));
        defence_y = canvas.height/2 + circle_orbit_radius * Math.sin(defence_theta * (Math.PI / 180));
      }

      else if(key.code == "KeyE")
      {
        defence_theta += 1;
        defence_x = canvas.width/2 + (ellipse_major) * Math.cos(defence_theta * (Math.PI / 180));
        defence_y = canvas.height/2 + (ellipse_minor) * Math.sin(defence_theta * (Math.PI / 180));
      }

      // need to change placement of defence_theta initialisation according to transition
      else if(key.code == "KeyS")
      {
        if(defence_x == square_left_x && defence_y > square_up_y)
        {
            defence_theta = 270;
            if((defence_y + square_defence_speed * Math.sin(defence_theta * (Math.PI / 180)) <= square_up_y))
            {
                defence_y = square_up_y;
            }
            else
            {
                defence_y += square_defence_speed * Math.sin(defence_theta * (Math.PI / 180));
            }
        }
        else if(defence_x == square_left_x + square_side && defence_y < square_up_y + square_side)
        {
            defence_theta = 90;
            if((defence_y + square_defence_speed * Math.sin(defence_theta * (Math.PI / 180)) >= square_up_y + square_side))
            {
                defence_y = square_up_y + square_side;
            }
            else
            {
                defence_y += square_defence_speed * Math.sin(defence_theta * (Math.PI / 180));
            }
        }
        else if(defence_y == square_up_y && defence_x < square_left_x + square_side)
        {
            defence_theta = 0;
            if(defence_x + square_defence_speed * Math.cos(defence_theta * (Math.PI / 180)) >= square_left_x + square_side)
            {
                defence_x = square_left_x + square_side;
            }
            else
            {
                defence_x += square_defence_speed * Math.cos(defence_theta * (Math.PI / 180));
            }
        }
        else if(defence_y == square_up_y + square_side && defence_x > square_left_x)
        {
            defence_theta = 180;
            if((defence_x - square_defence_speed * Math.cos(defence_theta * (Math.PI / 180)) <= square_left_x))
            {
                defence_x = square_left_x;
            }
            else
            {
                defence_x += square_defence_speed * Math.cos(defence_theta * (Math.PI / 180));
            }
        }
      }

      // need to change placement of defence_theta initialisation according to transition
      else if(key.code == "KeyT")
      {
        if(defence_theta == 60)
        {
            if(defence_x + triangle_speed * Math.cos(defence_theta * (Math.PI / 180)) >= triangle_top_x + triangle_halfside)
            {
                defence_x = triangle_top_x + triangle_halfside;
                defence_y = triangle_top_y + triangle_height;
                defence_theta = 180;
            }
            else
            {
                defence_x += triangle_speed * Math.cos(defence_theta * (Math.PI / 180));
                defence_y += triangle_speed * Math.sin(defence_theta * (Math.PI / 180));
            }
        }
        else if(defence_theta == 180)
        {
            if(defence_x + triangle_speed * Math.cos(defence_theta * (Math.PI / 180)) <= triangle_top_x - triangle_halfside)
            {
                defence_x = triangle_top_x - triangle_halfside;
                defence_theta = 300;
            }
            else
            {
                defence_x += triangle_speed * Math.cos(defence_theta * (Math.PI / 180));
                defence_y += triangle_speed * Math.sin(defence_theta * (Math.PI / 180));
            }
        }
        else if(defence_theta == 300)
        {
            if(defence_x + triangle_speed * Math.cos(defence_theta * (Math.PI / 180)) >= triangle_top_x)
            {
                defence_x = triangle_top_x;
                defence_y = triangle_top_y;
                defence_theta = 60;
            }
            else
            {
                defence_x += triangle_speed * Math.cos(defence_theta * (Math.PI / 180));
                defence_y += triangle_speed * Math.sin(defence_theta * (Math.PI / 180));
            }
        }
      }
    }


    var enemy = function(orbitR, selfR, time, color)
    {

        var centreX = orbitR * Math.cos(time * (Math.PI / 180)); //rcos(theta)
        var centreY = orbitR * Math.sin(time * (Math.PI / 180)); //rsin(theta)

        canvas.setDrawMode("fill");
        canvas.setColor(color);
        canvas.drawCircle(canvas.width/2 + centreX, canvas.height/2 + centreY, selfR);
    }

    function main() {
        canvas.clear();

        canvas.setDrawMode("fill");
        canvas.setColor("black");
        canvas.drawRectangle(0, 0, canvas.width, canvas.height)


        canvas.setDrawMode("fill");
        canvas.setColor("#FDB813");
        canvas.drawCircle(canvas.width/2, canvas.height/2, sunR);

        canvas.createGradient(canvas.width/2, canvas.height/2,100,600,800,'transparent', '#422d53');
        canvas.createGradient(canvas.width/2, canvas.height/2,1,80,100,'#fdcdbd', 'transparent');


        merOrb = COrbit(circle_orbit_radius);
        merOrb = EOrbit(ellipse_major,ellipse_minor);
        merOrb = ROrbit(square_side);
        merOrb = TOrbit(t_y,triangle_halfside);



        canvas.hello();
        Defence();
        canvas.keyDownCallback = move;

        e1O = COrbit(150, 'transparent');
        e1P = enemy(e1O, 5, Te1, "#d7b95e");
        Te1 += 0.5;
        e2O = COrbit(220,'transparent');
        e2P = enemy(e2O, 5, Te2, "#d7b95e");
        Te2 += 0.5;
        e3O = COrbit(360,'transparent');
        e3P = enemy(e3O, 5, Te3, "#d7b95e");
        Te3 += 0.5;
        e4O = COrbit(500,'transparent');
        e4P = enemy(e4O, 20, Te3, "blue");
        Te4 += 1;

    }


    canvas.mainFunction = main;
    canvas.setupFunction = setup;

    var timeStep = 1;
    canvas.startMain(timeStep);

</script>
